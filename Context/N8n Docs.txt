# N8N Docs

Splitting uses the [IF](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.if/) or [Switch](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.switch/) nodes. It turns a single-branch workflow into a multi-branch workflow. This is a key piece of representing complex logic in n8n.

Compare these workflows:

!["Diagram representing two workflows. One has three steps and follows a linear process, with a user submitting a bug, and the workflow emailing a support team. The second workflow starts the same way, but then splits depending on whether the user marked the issue as urgent. It then splits again depending on the user's support plan"](https://docs.n8n.io/_images/flow-logic/splitting/single-multi-branch-workflow.png)

This is the power of splitting and conditional nodes in n8n.

Refer to the [IF](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.if/) or [Switch](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.switch/) documentation for usage details.

# **Merging data[#](https://docs.n8n.io/flow-logic/merging/#merging-data)**

Merging brings multiple data streams together. You can achieve this using different nodes depending on your workflow requirements.

- Merge data from different data streams or nodes: Use the [Merge](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.merge/) node to combine data from various sources into one.
- Merge data from multiple node executions: Use the [Code](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.code/) node for complex scenarios where you need to merge data from multiple executions of a node or multiple nodes.
- Compare and merge data: Use the [Compare Datasets](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.comparedatasets/) node to compare, merge, and output data streams based on the comparison.

Explore each method in more detail in the sections below.

## **Merge data from different data streams[#](https://docs.n8n.io/flow-logic/merging/#merge-data-from-different-data-streams)**

If your workflow [splits](https://docs.n8n.io/flow-logic/splitting/), you combine the separate streams back into one stream.

Here's an [example workflow](https://n8n.io/workflows/1747-joining-different-datasets/) showing different types of merging: appending data sets, keeping only new items, and keeping only existing items. The [Merge node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.merge/) documentation contains details on each of the merge operations.

**Click to explore**

[View template details](https://n8n.io/workflows/1747-joining-different-datasets/)

## **Merge data from different nodes[#](https://docs.n8n.io/flow-logic/merging/#merge-data-from-different-nodes)**

You can use the Merge node to combine data from two previous nodes, even if the workflow hasn't split into separate data streams. This can be useful if you want to generate a single dataset from the data generated by multiple nodes.

*Merging data from two previous nodes*

![Merging data from two previous nodes. The diagram shows three nodes lined up sequentially. The first node is labeled Fetch data, the second is labeled Modify data, and the third is labeled Merge: append both data sets. Arrows connect nodes 1 to 2, 2 to 3, and 1 to 3.](https://docs.n8n.io/_images/flow-logic/merging/merge-node-data.png)

## **Merge data from multiple node executions[#](https://docs.n8n.io/flow-logic/merging/#merge-data-from-multiple-node-executions)**

Use the Code node to merge data from multiple node executions. This is useful in some [Looping](https://docs.n8n.io/flow-logic/looping/) scenarios.

**Node executions and workflow executions**

This section describes merging data from multiple node executions. This is when a node executes multiple times during a single workflow execution.

Refer to this [example workflow](https://n8n.io/workflows/1814-merge-multiple-runs-into-one/) using Loop Over Items and Wait to artificially create multiple executions.

**Click to explore**

[View template details](https://n8n.io/workflows/1814-merge-multiple-runs-into-one/)

## **Compare, merge, and split again[#](https://docs.n8n.io/flow-logic/merging/#compare-merge-and-split-again)**

The [Compare Datasets](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.comparedatasets/) node compares data streams before merging them. It outputs up to four different data streams.

Refer to this [example workflow](https://n8n.io/workflows/1943-comparing-data-with-the-compare-datasets-node/) for an example.

**Click to explore**

[View template details](https://n8n.io/workflows/1943-comparing-data-with-the-compare-datasets-node/)

Chat with the docs

# **Looping in n8n[#](https://docs.n8n.io/flow-logic/looping/#looping-in-n8n)**

Looping is useful when you want to process multiple items or perform an action repeatedly, such as sending a message to every contact in your address book. n8n handles this repetitive processing automatically, meaning you don't need to specifically build loops into your workflows. There are [some nodes](https://docs.n8n.io/flow-logic/looping/#node-exceptions) where this isn't true.

## **Using loops in n8n[#](https://docs.n8n.io/flow-logic/looping/#using-loops-in-n8n)**

n8n nodes take any number of items as input, process these items, and output the results. You can think of each item as a single data point, or a single row in the output table of a node.

![The Customer Datastore node output](https://docs.n8n.io/_images/flow-logic/looping/customer_datastore_node.png)

Nodes usually run once for each item. For example, if you wanted to send the name and notes of the customers in the Customer Datastore node as a message on Slack, you would:

1. Connect the Slack node to the Customer Datastore node.
2. Configure the parameters.
3. Execute the node.

You would receive five messages: one for each item.

This is how you can process multiple items without having to explicitly connect nodes in a loop.

### **Executing nodes once[#](https://docs.n8n.io/flow-logic/looping/#executing-nodes-once)**

For situations where you don't want a node to process all received items, for example sending a Slack message only to the first customer, you can do so by toggling the **Execute Once** parameter in the **Settings** tab of that node This setting is helpful when the incoming data contains multiple items and you want to only process the first one.

## **Creating loops[#](https://docs.n8n.io/flow-logic/looping/#creating-loops)**

n8n typically handles the iteration for all incoming items. However, there are certain scenarios where you will have to create a loop to iterate through all items. Refer to [Node exceptions](https://docs.n8n.io/flow-logic/looping/#node-exceptions) for a list of nodes that don't automatically iterate over all incoming items.

### **Loop until a condition is met[#](https://docs.n8n.io/flow-logic/looping/#loop-until-a-condition-is-met)**

To create a loop in an n8n workflow, connect the output of one node to the input of a previous node. Add an [IF](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.if/) node to check when to stop the loop.

Here is an [example workflow](https://n8n.io/workflows/1130) that implements a loop with an `IF` node:

![Editor UI view of sample workflow](https://docs.n8n.io/_images/flow-logic/looping/example_workflow.png)

### **Loop until all items are processed[#](https://docs.n8n.io/flow-logic/looping/#loop-until-all-items-are-processed)**

Use the [Loop Over Items](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.splitinbatches/) node when you want to loop until all items are processed. To process each item individually, set **Batch Size** to `1`.

You can batch the data in groups and process these batches. This approach is useful for avoiding API rate limits when processing large incoming data or when you want to process a specific group of returned items.

The Loop Over Items node stops executing after all the incoming items get divided into batches and passed on to the next node in the workflow so it's not necessary to add an IF node to stop the loop.

## **Node exceptions[#](https://docs.n8n.io/flow-logic/looping/#node-exceptions)**

Nodes and operations where you need to design a loop into your workflow:

- [CrateDB](https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.cratedb/) executes once for `insert` and `update`.
- [Code](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.code/) node in **Run Once for All Items** mode: processes all the items based on the entered code snippet.
- [Execute Workflow](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflow/) node in **Run Once for All Items** mode.
- [HTTP Request](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.httprequest/): you must handle pagination yourself. If your API call returns paginated results you must create a loop to fetch one page at a time.
- [Microsoft SQL](https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.microsoftsql/) executes once for `insert`, `update`, and `delete`.
- [MongoDB](https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.mongodb/) executes once for `insert` and `update`.
- [QuestDB](https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.questdb/) executes once for `insert`.
- [Redis](https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.redis/):
    - Info: this operation executes only once, regardless of the number of items in the incoming data.
- [RSS Read](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.rssfeedread/) executes once for the requested URL.
- [TimescaleDB](https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.timescaledb/) executes once for `insert` and `update`.

# **Waiting[#](https://docs.n8n.io/flow-logic/waiting/#waiting)**

Waiting allows you to pause a workflow mid-execution, then resume where the workflow left off, with the same data. This is useful if you need to rate limit your calls to a service, or wait for an external event to complete. You can wait for a specified duration, or until a webhook fires.

Making a workflow wait uses the [Wait](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/) node. Refer to the node documentation for usage details.

n8n provides a workflow template with a basic example of [Rate limiting and waiting for external events](https://n8n.io/workflows/1749-rate-limiting-and-waiting-for-external-events/).

Chat w

# **Sub-workflows[#](https://docs.n8n.io/flow-logic/subworkflows/#sub-workflows)**

You can call one workflow from another workflow. This allows you to build modular, microservice-like workflows. It can also help if your workflow grows large enough to encounter [memory issues](https://docs.n8n.io/hosting/scaling/memory-errors/). Creating sub-workflows uses the [Execute Workflow](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflow/) and [Execute Sub-workflow Trigger](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflowtrigger/) nodes.

Sub-wokflow executions don't count towards your plan's monthly execution or active workflow limits.

## **Set up and use a sub-workflow[#](https://docs.n8n.io/flow-logic/subworkflows/#set-up-and-use-a-sub-workflow)**

This section walks through setting up both the parent workflow and sub-workflow.

### **Create the sub-workflow[#](https://docs.n8n.io/flow-logic/subworkflows/#create-the-sub-workflow)**

1. Create a new workflow.
    
    **Create sub-workflows from existing workflows**
    
    You can optionally create a sub-workflow directly from an existing parent workflow using the [Execute Sub-workflow](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflow/) node. In the node, select the **Database** and **From list** options and select **Create a sub-workflow** in the list.
    
    You can also extract selected nodes directly using [Sub-workflow conversion](https://docs.n8n.io/workflows/subworkflow-conversion/) in the context menu.
    
2. **Optional**: configure which workflows can call the sub-workflow:
    1. Select the **Options**  menu > **Settings**. n8n opens the **Workflow settings** modal.
        
        ![Options menu](https://docs.n8n.io/_images/common-icons/three-dot-options-menu.png)
        
    2. Change the **This workflow can be called by** setting. Refer to [Workflow settings](https://docs.n8n.io/workflows/settings/) for more information on configuring your workflows.
3. Add the **Execute Sub-workflow** trigger node (if you are searching under trigger nodes, this is also titled **When Executed by Another Workflow**).
4. Set the **Input data mode** to choose how you will define the sub-workflow's input data:
    - **Define using fields below**: Choose this mode to define individual input names and data types that the calling workflow needs to provide. The [Execute Sub-workflow node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflow/) or [Call n8n Workflow Tool node](https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.toolworkflow/) in the calling workflow will automatically pull in the fields defined here.
    - **Define using JSON example**: Choose this mode to provide an example JSON object that demonstrates the expected input items and their types.
    - **Accept all data**: Choose this mode to accept all data unconditionally. The sub-workflow won't define any required input items. This sub-workflow must handle any input inconsistencies or missing values.
5. Add other nodes as needed to build your sub-workflow functionality.
6. Save the sub-workflow.

**Sub-workflow mustn't contain errors**

If there are errors in the sub-workflow, the parent workflow can't trigger it.

**Load data into sub-workflow before building**

This requires the ability to [load data from previous executions](https://docs.n8n.io/workflows/executions/debug/), which is available on n8n Cloud and registered Community plans.

If you want to load data into your sub-workflow to use while building it:

1. Create the sub-workflow and add the **Execute Sub-workflow Trigger**.
2. Set the node's **Input data mode** to **Accept all data** or define the input items using fields or JSON if they're already known.
3. In the sub-workflow [settings](https://docs.n8n.io/workflows/settings/), set **Save successful production executions** to **Save**.
4. Skip ahead to setting up the parent workflow, and run it.
5. Follow the steps to [load data from previous executions](https://docs.n8n.io/workflows/executions/debug/).
6. Adjust the **Input data mode** to match the input sent by the parent workflow if necessary.

You can now pin example data in the trigger node, enabling you to work with real data while configuring the rest of the workflow.

### **Call the sub-workflow[#](https://docs.n8n.io/flow-logic/subworkflows/#call-the-sub-workflow)**

1. Open the workflow where you want to call the sub-workflow.
2. Add the **Execute Sub-workflow** node.
3. In the **Execute Sub-workflow** node, set the sub-workflow you want to call. You can choose to call the workflow by ID, load a workflow from a local file, add workflow JSON as a parameter in the node, or target a workflow by URL.
    
    **Find your workflow ID**
    
    Your sub-workflow's ID is the alphanumeric string at the end of its URL.
    
4. Fill in the required input items defined by the sub-workflow.
5. Save your workflow.

When your workflow executes, it will send data to the sub-workflow, and run it.

You can follow the execution flow from the parent workflow to the sub-workflow by opening the Execute Sub-workflow node and selecting the **View sub-execution** link. Likewise, the sub-workflow's execution contains a link back to the parent workflow's execution to navigate in the other direction.

## **How data passes between workflows[#](https://docs.n8n.io/flow-logic/subworkflows/#how-data-passes-between-workflows)**

As an example, imagine you have an Execute Sub-workflow node in **Workflow A**. The Execute Sub-workflow node calls another workflow called **Workflow B**:

1. The Execute Sub-workflow node passes the data to the Execute Sub-workflow Trigger node (titled "When executed by another node" in the canvas) of **Workflow B**.
2. The last node of **Workflow B** sends the data back to the Execute Sub-workflow node in **Workflow A**.

## **Sub-workflow conversion[#](https://docs.n8n.io/flow-logic/subworkflows/#sub-workflow-conversion)**

See [sub-workflow conversion](https://docs.n8n.io/workflows/subworkflow-conversion/) for how to divide your existing workflows into sub-workflows.

# **rror handling[#](https://docs.n8n.io/flow-logic/error-handling/#error-handling)**

When designing your flow logic, it's a good practice to consider potential errors, and set up methods to handle them gracefully. With an error workflow, you can control how n8n responds to a workflow execution failure.

**Investigating errors**

To investigate failed executions, you can:

- Review your [Executions](https://docs.n8n.io/workflows/executions/), for a [single workflow](https://docs.n8n.io/workflows/executions/single-workflow-executions/) or [all workflows you have access to](https://docs.n8n.io/workflows/executions/all-executions/). You can [load data from previous execution](https://docs.n8n.io/workflows/executions/debug/) into your current workflow.
- Enable [Log streaming](https://docs.n8n.io/log-streaming/).

## **Create and set an error workflow[#](https://docs.n8n.io/flow-logic/error-handling/#create-and-set-an-error-workflow)**

For each workflow, you can set an error workflow in **Workflow Settings**. It runs if an execution fails. This means you can, for example, send email or Slack alerts when a workflow execution errors. The error workflow must start with the [Error Trigger](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.errortrigger/).

You can use the same error workflow for multiple workflows.

1. Create a new workflow, with the Error Trigger as the first node.
2. Give the workflow a name, for example `Error Handler`.
3. Select **Save**.
4. In the workflow where you want to use this error workflow:
    1. Select **Options**  > **Settings**.
        
        ![Options menu icon](https://docs.n8n.io/_images/common-icons/three-dot-options-menu.png)
        
    2. In **Error workflow**, select the workflow you just created. For example, if you used the name Error Handler, select **Error handler**.
    3. Select **Save**. Now, when this workflow errors, the related error workflow runs.

## **Error data[#](https://docs.n8n.io/flow-logic/error-handling/#error-data)**

The default error data received by the Error Trigger is:

`[
	{
		"execution": {
			"id": "231",
			"url": "https://n8n.example.com/execution/231",
			"retryOf": "34",
			"error": {
				"message": "Example Error Message",
				"stack": "Stacktrace"
			},
			"lastNodeExecuted": "Node With Error",
			"mode": "manual"
		},
		"workflow": {
			"id": "1",
			"name": "Example Workflow"
		}
	}
]`

---

All information is always present, except:

- `execution.id`: requires the execution to be saved in the database. Not present if the error is in the trigger node of the main workflow, as the workflow doesn't execute.
- `execution.url`: requires the execution to be saved in the database. Not present if the error is in the trigger node of the main workflow, as the workflow doesn't execute.
- `execution.retryOf`: only present when the execution is a retry of a failed execution.

If the error is caused by the trigger node of the main workflow, rather than a later stage, the data sent to the error workflow is different. There's less information in `execution{}` and more in `trigger{}`:

`{
  "trigger": {
    "error": {
      "context": {},
      "name": "WorkflowActivationError",
      "cause": {
        "message": "",
        "stack": ""
      },
      "timestamp": 1654609328787,
      "message": "",
      "node": {
        . . . 
      }
    },
    "mode": "trigger"
  },
  "workflow": {
    "id": "",
    "name": ""
  }
}`

---

## **Cause a workflow execution failure using Stop And Error[#](https://docs.n8n.io/flow-logic/error-handling/#cause-a-workflow-execution-failure-using-stop-and-error)**

When you create and set an error workflow, n8n runs it when an execution fails. Usually, this is due to things like errors in node settings, or the workflow running out of memory.

You can add the [Stop And Error](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.stopanderror/) node to your workflow to force executions to fail under your chosen circumstances, and trigger the error workflow.

# **Execution order in multi-branch workflows[#](https://docs.n8n.io/flow-logic/execution-order/#execution-order-in-multi-branch-workflows)**

n8n's node execution order depends on the version of n8n you're using:

- For workflows created before version 1.0: n8n executes the first node of each branch, then the second node of each branch, and so on.
- For workflows created in version 1.0 and above: executes each branch in turn, completing one branch before starting another. n8n orders the branches based on their position on the [canvas](https://docs.n8n.io/glossary/#canvas-n8n), from topmost to bottommost. If two branches are at the same height, the leftmost branch executes first.

You can change the execution order in your [workflow settings](https://docs.n8n.io/workflows/settings/).

# Data

# **Data structure[#](https://docs.n8n.io/data/data-structure/#data-structure)**

In n8n, all data passed between nodes is an array of objects. It has the following structure:

`[
	{
		// For most data:
		// Wrap each item in another object, with the key 'json'
		"json": {
			// Example data
			"apple": "beets",
			"carrot": {
				"dill": 1
			}
		},
		// For binary data:
		// Wrap each item in another object, with the key 'binary'
		"binary": {
			// Example data
			"apple-picture": {
				"data": "....", // Base64 encoded binary data (required)
				"mimeType": "image/png", // Best practice to set if possible (optional)
				"fileExtension": "png", // Best practice to set if possible (optional)
				"fileName": "example.png", // Best practice to set if possible (optional)
			}
		}
	},
]`

---

**Skipping the `json` key and array syntax**

From 0.166.0 on, when using the Function node or Code node, n8n automatically adds the `json` key if it's missing. It also automatically wraps your items in an array (`[]`) if needed. This is only the case when using the Function or Code nodes. When building your own nodes, you must still make sure the node returns data with the `json` key.

## **Data item processing[#](https://docs.n8n.io/data/data-structure/#data-item-processing)**

Nodes can process multiple items.

For example, if you set the Trello node to `Create-Card`, and create an expression that sets `Name` using a property called `name-input-value` from the incoming data, the node creates a card for each item, always choosing the `name-input-value` of the current item.

For example, this input will create two cards. One named `test1` the other one named `test2`:

`[
	{
		name-input-value: "test1"
	},
	{
		name-input-value: "test2"
	}
]`

---

Chat

# **Data flow within nodes[#](https://docs.n8n.io/data/data-flow-nodes/#data-flow-within-nodes)**

Nodes can process multiple items.

For example, if you set the Trello node to `Create-Card`, and create an expression that sets `Name` using a property called `name-input-value` from the incoming data, the node creates a card for each item, always choosing the `name-input-value` of the current item.

For example, this input will create two cards. One named `test1` the other one named `test2`:

`[
	{
		name-input-value: "test1"
	},
	{
		name-input-value: "test2"
	}
]`

---

# **Transforming data[#](https://docs.n8n.io/data/transforming-data/#transforming-data)**

n8n uses a predefined [data structure](https://docs.n8n.io/data/data-structure/) that allows all nodes to process incoming data correctly.

Your incoming data may have a different data structure, in which case you will need to transform it to allow each item to be processed individually.

For example, the image below shows the output of an [HTTP Request](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.httprequest/) node that returns data incompatible with n8n's data structure. The node returns the data and displays that only one item was returned.

![HTTP Request node output](https://docs.n8n.io/_images/data/transforming-data/HTTPRequest_output.png)

To transform this kind of structure into the n8n data structure you can use the data transformation nodes:

- [Aggregate](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.aggregate/): take separate items, or portions of them, and group them together into individual items.
- [Limit](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.limit/): remove items beyond a defined maximum number.
- [Remove Duplicates](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.removeduplicates/): identify and delete items that are identical across all fields or a subset of fields.
- [Sort](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.sort/): organize lists of in a desired ordering, or generate a random selection.
- [Split Out](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.splitout/): separate a single data item containing a list into multiple items.
- [Summarize](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.summarize/): aggregate items together, in a manner similar to Excel pivot tables.

# **Processing data with code[#](https://docs.n8n.io/data/code/#processing-data-with-code)**

## **Function[#](https://docs.n8n.io/data/code/#function)**

A function is a block of code designed to perform a certain task. In n8n, you can write custom JavaScript or Python code snippets to add, remove, and update the data you receive from a node.

The [Code](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.code/) node gives you access to the incoming data and you can manipulate it. With this node you can create any function you want using JavaScript code.

# **Mapping in the UI[#](https://docs.n8n.io/data/data-mapping/data-mapping-ui/#mapping-in-the-ui)**

Data mapping means referencing data from previous nodes. It doesn't include changing (transforming) data, just referencing it.

You can map data in the following ways:

- Using the expressions editor.
- By dragging and dropping data from the **INPUT** into parameters. This generates the expression for you.

For information on errors with mapping and linking items, refer to [Item linking errors](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/).

## **How to drag and drop data[#](https://docs.n8n.io/data/data-mapping/data-mapping-ui/#how-to-drag-and-drop-data)**

1. Run your workflow to load data.
2. Open the node where you need to map data.
3. You can map in table, JSON, and schema view:
    - In table view: click and hold a table heading to map top level data, or a field in the table to map nested data.
    - In JSON view: click and hold a key.
    - In schema view: click and hold a key.
4. Drag the item into the field where you want to use the data.

### **Understand what you're mapping with drag and drop[#](https://docs.n8n.io/data/data-mapping/data-mapping-ui/#understand-what-youre-mapping-with-drag-and-drop)**

Data mapping maps the key path, and loads the key's value into the field. For example, given the following data:

`[
	{
		"fruit": "apples",
		"color": "green"
	}
]`

---

You can map `fruit` by dragging and dropping **fruit** from the **INPUT** into the field where you want to use its value. This creates an expression, `{{ $json.fruit }}`. When the node iterates over input items, the value of the field becomes the value of `fruit` for each item.

### **Understand nested data[#](https://docs.n8n.io/data/data-mapping/data-mapping-ui/#understand-nested-data)**

Given the following data:

`[
  {
    "name": "First item",
    "nested": {
      "example-number-field": 1,
      "example-string-field": "apples"
    }
  },
  {
    "name": "Second item",
    "nested": {
      "example-number-field": 2,
      "example-string-field": "oranges"
    }
  }
]`

---

n8n displays it in table form like this:

!["Screenshot of a table in the INPUT panel. It includes a top level field named "nested." This field contains nested data, which is indicated in bold."](https://docs.n8n.io/_images/data/data-mapping/nested-data.png)

# **Mapping in the expressions editor[#](https://docs.n8n.io/data/data-mapping/data-mapping-expressions/#mapping-in-the-expressions-editor)**

These examples show how to access linked items in the expressions editor. Refer to [expressions](https://docs.n8n.io/code/expressions/) for more information on expressions, including built in variables and methods.

For information on errors with mapping and linking items, refer to [Item linking errors](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/).

## **Access the linked item in a previous node's output[#](https://docs.n8n.io/data/data-mapping/data-mapping-expressions/#access-the-linked-item-in-a-previous-nodes-output)**

When you use this, n8n works back up the item linking chain, to find the parent item in the given node.

`// Returns the linked item
{{$("<node-name>").item}}`

---

As a longer example, consider a scenario where a node earlier in the workflow has the following output data:

`[
  {
    "id": "23423532",
    "name": "Jay Gatsby",
  },
  {
    "id": "23423533",
    "name": "José Arcadio Buendía",
  },
  {
    "id": "23423534",
    "name": "Max Sendak",
  },
  {
    "id": "23423535",
    "name": "Zaphod Beeblebrox",
  },
  {
    "id": "23423536",
    "name": "Edmund Pevensie",
  }
]`

---

To extract the name, use the following expression:

`{{$("<node-name>").item.json.name}}`

---

### **Access the linked item in the current node's input[#](https://docs.n8n.io/data/data-mapping/data-mapping-expressions/#access-the-linked-item-in-the-current-nodes-input)**

In this case, the item linking is within the node: find the input item that the node links to an output item.

`// Returns the linked item
{{$input.item}}`

---

As a longer example, consider a scenario where the current node has the following input data:

`[
  {
    "id": "23423532",
    "name": "Jay Gatsby",
  },
  {
    "id": "23423533",
    "name": "José Arcadio Buendía",
  },
  {
    "id": "23423534",
    "name": "Max Sendak",
  },
  {
    "id": "23423535",
    "name": "Zaphod Beeblebrox",
  },
  {
    "id": "23423536",
    "name": "Edmund Pevensie",
  }
]`

---

To extract the name, you'd normally use drag-and-drop [Data mapping](https://docs.n8n.io/data/data-mapping/), but you could also write the following expression:

`{{$input.item.json.name}}`

---

# **Item linking concepts[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/#item-linking-concepts)**

Each output item created by a node includes metadata that links them to the input item (or items) that the node used to generate them. This creates a chain of items that you can work back along to access previous items. This can be complicated to understand, especially if the node splits or merges data. You need to understand item linking when building your own programmatic nodes, or in some scenarios using the Code node.

This document provides a conceptual overview of this feature. For usage details, refer to:

- [Item linking for node creators](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-node-building/), for details on how to handle item linking when building a node.
- [Item linking in the Code node](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-code-node/), to learn how to handle item linking in the Code node.
- [Item linking errors](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/), to understand the errors you may encounter in the editor UI.

## **n8n's automatic item linking[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/#n8ns-automatic-item-linking)**

If a node doesn't control how to link input items to output items, n8n tries to guess how to link the items automatically:

- Single input, single output: the output links to the input.
- Single input, multiple outputs: all outputs link to that input.
- Multiple inputs and outputs:
    - If you keep the input items, but change the order (or remove some but keep others), n8n can automatically add the correct linked item information.
    - If the number of inputs and outputs is equal, n8n links the items in order. This means that output-1 links to input-1, output-2 to input-2, and so on.
    - If the number isn't equal, or you create completely new items, n8n can't automatically link items.

If n8n can't link items automatically, and the node doesn't handle the item linking, n8n displays an error. Refer to [Item linking errors](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/) for more information.

## **Item linking example[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/#item-linking-example)**

![A diagram showing the threads linking multiple items back through a workflow](https://docs.n8n.io/_images/data/data-mapping/data-item-linking/item-linking-multiple-lines.png)

In this example, it's possible for n8n to link an item in one node back several steps, despite the item order changing. This means the node that sorts movies alphabetically can access information about the linked item in the node that gets famous movie actors.

The methods for accessing linked items are different depending on whether you're using the UI, expressions, or the code node. Explore the following resources:

- [Mapping in the UI](https://docs.n8n.io/data/data-mapping/data-mapping-ui/)
- [Mapping in the expressions editor](https://docs.n8n.io/data/data-mapping/data-mapping-expressions/)
- [Item linking in the Code node](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-code-node/)
- [Item linking errors](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/)

# **Item linking in the Code node[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-code-node/#item-linking-in-the-code-node)**

Use n8n's item linking to access data from items that precede the current item. It also has implications when using the Code node. Most nodes link every output item to an input item. This creates a chain of items that you can work back along to access previous items. For a deeper conceptual overview of this topic, refer to [Item linking concepts](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/). This document focuses on practical usage examples.

When using the Code node, there are some scenarios where you need to manually supply item linking information if you want to be able to use `$("<node-name>").item` later in the workflow. All these scenarios only apply if you have more than one incoming item. n8n automatically handles item linking for single items.

These scenarios are when you:

- Add new items: the new items aren't linked to any input.
- Return new items.
- Want to manually control the item linking.

[n8n's automatic item linking](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/) handles the other scenarios.

To control item linking, set `pairedItem` when returning data. For example, to link to the item at index 0:

`[
	{
		"json": {
			. . . 
		},
		// The index of the input item that generated this output item
		"pairedItem": 0
	}
]`

---

### **`pairedItem` usage example[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-code-node/#paireditem-usage-example)**

Take this input data:

`[
  {
    "id": "23423532",
    "name": "Jay Gatsby"
  },
  {
    "id": "23423533",
    "name": "José Arcadio Buendía"
  },
  {
    "id": "23423534",
    "name": "Max Sendak"
  },
  {
    "id": "23423535",
    "name": "Zaphod Beeblebrox"
  },
  {
    "id": "23423536",
    "name": "Edmund Pevensie"
  }
]`

---

And use it to generate new items, containing just the name, along with a new piece of data:

`newItems = [];
for(let i=0; i<items.length; i++){
  newItems.push(
    {
    "json":
      {
        "name": items[i].json.name,
				"aBrandNewField": "New data for item " + i
      }
    }
  )
}

return newItems;`

---

`newItems` is an array of items with no `pairedItem`. This means there's no way to trace back from these items to the items used to generate them.

Add the `pairedItem` object:

`newItems = [];
for(let i=0; i<items.length; i++){
  newItems.push(
    {
      "json":
        {
          "name": items[i].json.name,
					"aBrandNewField": "New data for item " + i
        },
      "pairedItem": i
    }    
  )
}
return newItems;`

---

Each new item now links to the item used to create it.

# **Item linking errors[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/#item-linking-errors)**

In n8n you can reference data from any previous node. This doesn't have to be the node just before: it can be any previous node in the chain. When referencing nodes further back, you use the expression syntax `$(node_name).item`.

![A diagram showing the threads linking multiple items back through a workflow](https://docs.n8n.io/_images/data/data-mapping/data-item-linking/item-linking-multiple-lines.png)

*Diagram of threads for different items. Due to the item linking, you can get the actor for each movie using `$('Get famous movie actors').item`.*

Since the previous node can have multiple items in it, n8n needs to know which one to use. When using `.item`, n8n figures this out for you behind the scenes. Refer to [Item linking concepts](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/) for detailed information on how this works.

`.item` fails if information is missing. To figure out which item to use, n8n maintains a thread back through the workflow's nodes for each item. For a given item, this thread tells n8n which items in previous nodes generated it. To find the matching item in a given previous node, n8n follows this thread back until it reaches the node in question.

When using `.item`, n8n displays an error when:

- The thread is broken
- The thread points to more than one item in the previous node (as it's unclear which one to use)

To solve these errors, you can either avoid using `.item`, or fix the root cause.

You can avoid `.item` by using `.first()`, `.last()` or `.all()[index]` instead. They require you to know the position of the item that you’re targeting within the target node's output items. Refer to [Built in methods and variables | Output of other nodes](https://docs.n8n.io/code/builtin/output-other-nodes/) for more detail on these methods.

The fix for the root cause depends on the exact error.

### **Fix for 'Info for expressions missing from previous node'[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/#fix-for-info-for-expressions-missing-from-previous-node)**

If you see this error message:

> ERROR: Info for expression missing from previous node
> 

There's a node in the chain that doesn't return pairing information. The solution here depends on the type of the previous node:

- Code nodes: make sure you return which input items the node used to produce each output item. Refer to [Item linking in the code node](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-code-node/) for more information.
- Custom or community nodes: the node creator needs to update the node to return which input items it uses to produce each output item. Refer to [Item linking for node creators](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-node-building/) for more information.

### **Fix for 'Multiple matching items for expression'[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/#fix-for-multiple-matching-items-for-expression)**

This is the error message:

> ERROR: Multiple matching items for expression
> 

Sometimes n8n uses multiple items to create a single item. Examples include the Summarize, Aggregate, and Merge nodes. These nodes can combine information from multiple items.

When you use `.item` and there are multiple possible matches, n8n doesn't know which one to use. To solve this you can either:

- Use `.first()`, `.last()` or `.all()[index]` instead. Refer to [Built in methods and variables | Output of other nodes](https://docs.n8n.io/code/builtin/output-other-nodes/) for more detail on these methods.
- Reference a different node that contains the same information, but doesn't have multiple matching items.

# **Item linking for node creators[#](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-node-building/#item-linking-for-node-creators)**

**Programmatic-style nodes only**

This guidance applies to programmatic-style nodes. If you're using declarative style, n8n handles paired items for you automatically.

Use n8n's item linking to access data from items that precede the current item. n8n needs to know which input item a given output item comes from. If this information is missing, expressions in other nodes may break. As a node developer, you must ensure any items returned by your node support this.

This applies to programmatic nodes (including trigger nodes). You don't need to consider item linking when building a declarative-style node. Refer to [Choose your node building approach](https://docs.n8n.io/integrations/creating-nodes/plan/choose-node-method/) for more information on node styles.

Start by reading [Item linking concepts](https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-concepts/), which provides a conceptual overview of item linking, and details of the scenarios where n8n can handle the linking automatically.

If you need to handle item linking manually, do this by setting `pairedItem` on each item your node returns:

`// Use the pairedItem information of the incoming item
newItem = {
	"json": { . . . },
	"pairedItem": {
		"item": item.pairedItem,
		// Optional: choose the input to use
		// Set this if your node combines multiple inputs
		"input": 0
};

// Or set the index manually
newItem = {
		"json": { . . . }
		"pairedItem": {
			"item": i,
			// Optional: choose the input to use
			// Set this if your node combines multiple inputs
			"input": 0
		},
};`

---

# **Data pinning[#](https://docs.n8n.io/data/data-pinning/#data-pinning)**

You can 'pin' data during workflow development. Data pinning means saving the output data of a node, and using the saved data instead of fetching fresh data in future workflow executions.

You can use this when working with data from external sources to avoid having to repeat requests to the external system. This can save time and resources:

- If your workflow relies on an external system to trigger it, such as a webhook call, being able to pin data means you don't need to use the external system every time you test the workflow.
- If the external resource has data or usage limits, pinning data during tests avoids consuming your resource limits.
- You can fetch and pin the data you want to test, then have confidence that the data is consistent in all your workflow tests.

You can only pin data for nodes that have a single main output ("error" outputs don't count for this purpose).

**For development only**

Data pinning isn't available for production workflow executions. It's a feature to help test workflows during development.

## **Pin data[#](https://docs.n8n.io/data/data-pinning/#pin-data)**

To pin data in a node:

1. Run the node to load data.
2. In the **OUTPUT** view, select **Pin data** . When data pinning is active, the button is disabled and a "This data is pinned" banner is displayed in the **OUTPUT** view.
    
    ![Pin data icon](https://docs.n8n.io/_images/data/data-pinning/data-pinning-button.png)
    

**Nodes that output binary data**

You can't pin data if the output data includes binary data.

## **Unpin data[#](https://docs.n8n.io/data/data-pinning/#unpin-data)**

When data pinning is active, a banner appears at the top of the node's output panel indicating that n8n has pinned the data. To unpin data and fetch fresh data on the next execution, select the **Unpin** link in the banner.

# **Data editing[#](https://docs.n8n.io/data/data-editing/#data-editing)**

n8n allows you to edit [pinned data](https://docs.n8n.io/data/data-pinning/). This means you can check different scenarios without setting up each scenario and sending the relevant data from your external system. It makes it easier to test edge cases.

**For development only**

Data editing isn't available for production workflow executions. It's a feature to help test workflows during development.

## **Edit output data[#](https://docs.n8n.io/data/data-editing/#edit-output-data)**

To edit output data:

1. Run the node to load data.
2. In the **OUTPUT** view, select **JSON** to switch to JSON view.
3. Select **Edit** .
    
    ![Edit data icon](https://docs.n8n.io/_images/data/data-pinning/edit-data.png)
    
4. Edit your data.
5. Select **Save**. n8n saves your data changes and pins your data.

## **Use data from previous executions[#](https://docs.n8n.io/data/data-editing/#use-data-from-previous-executions)**

You can copy data from nodes in previous workflow executions:

1. Open the left menu.
2. Select **Executions**.
3. Browse the workflow executions list to find the one with the data you want to copy.
4. Select **Open Past Execution** .
    
    ![Open past execution icon](https://docs.n8n.io/_images/data/data-pinning/open-execution.png)
    
5. Double click the node whose data you want to copy.
6. If it's table layout, select **JSON** to switch to JSON view.
7. There are two ways to copy the JSON:
8. Select the JSON you want by highlighting it, like selecting text. Then use `ctrl` + `c` to copy it.
9. Select the JSON you want to copy by clicking on a parameter. Then:
    1. Hover over the JSON. n8n displays the **Copy**  button.
        
        ![Copy data icon](https://docs.n8n.io/_images/data/data-pinning/copy-data.png)
        
    2. Select **Copy** .
        
        ![Copy data icon](https://docs.n8n.io/_images/data/data-pinning/copy-data.png)
        
    3. You can choose what to copy:
        - **Copy Item Path** and **Copy Parameter Path** gives you expressions that access parts of the JSON.
        - **Copy Value**: copies the entire selected JSON.
10. Return to the workflow you're working on:
    1. Open the left menu.
    2. Select **Workflows**.
    3. Select **Open**.
    4. Select the workflow you want to open.
11. Open the node where you want to use the copied data.
12. If there is no data, run the node to load data.
13. In the **OUTPUT** view, select **JSON** to switch to JSON view.
14. Select **Edit** .
    
    ![Edit data icon](https://docs.n8n.io/_images/data/data-pinning/edit-data.png)
    
15. Paste in the data from the previous execution.
16. Select **Save**. n8n saves your data changes and pins your data.

# **Data filtering[#](https://docs.n8n.io/data/data-filtering/#data-filtering)**

**Feature availability**

Available on Cloud Pro and Enterprise plans.

Search and filter data in the node **INPUT** and **OUTPUT** panels. Use this to check your node's data.

To search:

1. In a node, select **Search**  in the **INPUT** or **OUTPUT** panel.
    
    ![Search icon](https://docs.n8n.io/_images/common-icons/search.png)
    
2. Enter your search term.

n8n filters as you type your search, displaying the objects or rows containing the term.

Filtering is purely visual: n8n doesn't change or delete data. The filter resets when you close and reopen the node.

# **Data mocking[#](https://docs.n8n.io/data/data-mocking/#data-mocking)**

Data mocking is simulating or faking data. It's useful when developing a workflow. By mocking data, you can:

- Avoid making repeated calls to your data source. This saves time and costs.
- Work with a small, predictable dataset during initial development.
- Avoid the risk of overwriting live data: in the early stages of building your workflow, you don't need to connect your real data source.

## **Mocking with real data using data pinning[#](https://docs.n8n.io/data/data-mocking/#mocking-with-real-data-using-data-pinning)**

Using [data pinning](https://docs.n8n.io/data/data-pinning/), you load real data into your workflow, then pin it in the output panel of a node. Using this approach you have realistic data, with only one call to your data source. You can [edit pinned data](https://docs.n8n.io/data/data-editing/).

Use this approach when you need to configure your workflow to handle the exact data structure and parameters provided by your data source.

To pin data in a node:

1. Run the node to load data.
2. In the **OUTPUT** view, select **Pin data** . When data pinning is active, the button is disabled and a "This data is pinned" banner is displayed in the **OUTPUT** view.
    
    ![Pin data icon](https://docs.n8n.io/_images/data/data-pinning/data-pinning-button.png)
    

**Nodes that output binary data**

You can't pin data if the output data includes binary data.

## **Generate custom data using the Code or Edit Fields nodes[#](https://docs.n8n.io/data/data-mocking/#generate-custom-data-using-the-code-or-edit-fields-nodes)**

You can create a custom dataset in your workflow using either the [Code node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.code/) or the [Edit Fields (Set) node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.set/).

In the Code node, you can create any data set you want, and return it as the node output. In the Edit Fields node, select **Add fields** to add your custom data.

The Edit Fields node is a good choice for small tests. To create more complex datasets, use the Code node.

## **Output a sample data set from the Customer Datastore node[#](https://docs.n8n.io/data/data-mocking/#output-a-sample-data-set-from-the-customer-datastore-node)**

The Customer Datastore node provides a fake dataset to work with. Add and execute the node to explore the data.

Use this approach if you need some test data when exploring n8n, and you don't have a real use-case to work with.

Chat

# **Data tables[#](https://docs.n8n.io/data/data-tables/#data-tables)**

## **Overview[#](https://docs.n8n.io/data/data-tables/#overview)**

Data tables integrate data storage within your n8n environment. Using data tables, you can save, manage, and interact with data directly inside your workflows without relying on external database systems for scenarios such as:

- Persisting data across workflows in the same project
- Storing markers to prevent duplicate runs or control workflow triggers
- Reusing prompts or messages across workflows
- Storing evaluation data for AI workflows
- Storing data generated from workflow executions
- Combining data from different sources to enrich your datasets
- Creating lookup tables as quick reference points within workflows

## **How to use data tables[#](https://docs.n8n.io/data/data-tables/#how-to-use-data-tables)**

There are two parts to working with data tables: creating them and interacting with them in workflows.

### **Step 1: Creating a data table[#](https://docs.n8n.io/data/data-tables/#step-1-creating-a-data-table)**

1. In your n8n project, select the **Data tables** tab.
2. Click the split button located in the top right corner and select **Create Data table**.
    
    ![Data table creation](https://docs.n8n.io/_images/data/data-tables/create-data-table.png)
    
3. Enter a descriptive name for your table.

In the table view that appears, you can:

- Add and reorder columns to organize your data
- Add, delete, and update rows
- Edit existing data

### **Step 2: Interacting with Data tables in workflows[#](https://docs.n8n.io/data/data-tables/#step-2-interacting-with-data-tables-in-workflows)**

Interact with data tables in your workflow using the **Data table** node, which allows you to retreive, update, and manipulate the data stored in a Data table.

See [Data table node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.datatable/).

## **Considerations and limitations of data tables[#](https://docs.n8n.io/data/data-tables/#considerations-and-limitations-of-data-tables)**

- Data tables are suitable for light to moderate data storage. By default, a data table can't contain more than 50MB of data. In self-hosted environments, you can increase this default size limit using the environment variable `N8N_DATA_TABLES_MAX_SIZE_BYTES`.
- When a data table approaches 80% of your storage limit, a warning will alert you. A final warning appears when you reach the storage limit. Exceeding this limit will disable manual additions to tables and cause workflow execution errors during attempts to insert or update data.
- By default, data tables created within a project are accessible to all team members in that project.
- Tables created in a **Personal** space are only accessible by their creator.

## **Data tables versus variables[#](https://docs.n8n.io/data/data-tables/#data-tables-versus-variables)**

| **Feature** | **Data tables** | **Variables** |
| --- | --- | --- |
| Unified tabular view | ✓ | ✗ |
| Row-column relationships | ✓ | ✗ |
| Cross-project access | ✗ | ✓ |
| Individual value display | ✗ | ✓ |
| Optimized for short values | ✗ | ✓ |
| Structured data | ✓ | ✗ |
| Scoped to projects | ✓ | ✗ |
| Use values as expressions | ✗ | ✓ |

## **Exporting and importing data[#](https://docs.n8n.io/data/data-tables/#exporting-and-importing-data)**

To transfer data between n8n and external tools, use workflows that:

1. Retrieve data from a data table.
2. Export it using an API or file export.
3. Import data into another system or data table accordingly.
    
    ![Data export workflow](https://docs.n8n.io/_images/data/data-tables/data-table-export.png)
    

Chat with the docs

# **Binary data[#](https://docs.n8n.io/data/binary-data/#binary-data)**

Binary data is any file-type data, such as image files or documents.

This page collects resources relating to binary data in n8n.

## **Working with binary data in your workflows[#](https://docs.n8n.io/data/binary-data/#working-with-binary-data-in-your-workflows)**

You can process binary data in n8n workflows. n8n provides nodes to help you work with binary data. You can also use code.

### **Nodes[#](https://docs.n8n.io/data/binary-data/#nodes)**

There are three key nodes dedicated to handling binary data files:

- [Read/Write Files from Disk](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.readwritefile/) to read and write files from/to the machine where n8n is running.
- [Convert to File](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.converttofile/) to take input data and output it as a file.
- [Extract From File](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.extractfromfile/) to get data from a binary format and convert it to JSON.

There are separate nodes for working with XML and HTML data:

- [HTML](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.html/)
- [XML](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.xml/)

And nodes for performing common tasks:

- [Compression](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.compression/)
- [Edit Image](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.editimage/)
- [FTP](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.ftp/)

You can trigger a workflow based on changes to a local file using the [Local File trigger](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.localfiletrigger/).

To split or concatenate binary data items, use the [data transformation nodes](https://docs.n8n.io/data/#data-transformation-nodes).

### **Code[#](https://docs.n8n.io/data/binary-data/#code)**

You can use the [Code node](https://docs.n8n.io/code/code-node/) to manipulate binary data in your workflows. For example, [Get the binary data buffer](https://docs.n8n.io/code/cookbook/code-node/get-binary-data-buffer/): get the binary data available in your workflow.

## **Configure binary data mode when self-hosting[#](https://docs.n8n.io/data/binary-data/#configure-binary-data-mode-when-self-hosting)**

You can configure how your self-hosted n8n instance handles binary data using the [Binary data environment variables](https://docs.n8n.io/hosting/configuration/environment-variables/binary-data/). This includes tasks such as setting the storage path and choosing how to store binary data.

Your configuration affects how well n8n scales: [Scaling | Binary data filesystem mode](https://docs.n8n.io/hosting/scaling/binary-data/).

Reading and writing binary files can have security implications. If you want to disable reading and writing binary data, use the `NODES_EXCLUDE` environment variable. Refer to [Environment variables | Nodes](https://docs.n8n.io/hosting/configuration/environment-variables/nodes/) for more information.

# **Schema Preview[#](https://docs.n8n.io/data/schema-preview/#schema-preview)**

Schema Preview exposes expected schema data from the previous node in the Node Editor without the user having to provide credentials or execute the node. This makes it possible to construct workflows without having to provide credentials in advance. The preview doesn't include mock data, but it does expose the expected fields, making it possible to select and incorporate them into the input of subsequent nodes.

## **Using the preview[#](https://docs.n8n.io/data/schema-preview/#using-the-preview)**

1. There must be a node with Schema Preview available in your workflow.
2. When clicking on the details of the next node in the sequence, the Schema Preview data will show up in the Node Editor where schema data would typically be exposed.
3. Use data from the Schema Preview just as you would other schemas - drag and drop fields as input into your node parameters and settings.